---
title: "ENVS-193DS Final"
author: "Rebecca Martinez"
date: "June 12, 2025"
format:
  html: 
    toc: true 
    warning: false 
    message: false 
    error: false
---

üíª [**GitHub Repository**](https://github.com/RebeccaLMartinez/ENVS-193DS_spring-2025_final)

```{r setup,  message=FALSE, warning=FALSE, error=FALSE}

# --- necessary packages (possibly more) ---

library(tidyverse)   # Basic necessity
library(here)        # File path management
library(janitor)     # Cleans names
library(readxl)      # Read Excel files
library(scales)      # Customize axis labels
library(ggeffects)   # For model predictions
library(ggthemes)
library(flextable)   # Creates tables 
library(rstatix)     # Easy statistical tests
library(effectsize)  # Calculate effect sizes
library(lubridate)   # To work with dates
library(paletteer)   # Color package
library(DHARMa)
library(MuMIn)  # model selection (be advisedL Warning message: package ‚ÄòMuMIn‚Äô was built under R version 4.3.3 )


# --- sea surface temperature data ---

sst <- read_csv(here("data", "sst_update2023.csv"))  # SST data CSV file

str(sst)

# --- 

nest_boxes <- read_csv(here("data", "occdist.csv"))

str(nest_boxes)
slice(nest_boxes)
head(nest_boxes)
```

# Problem 1. Research writing 

## a. Transparent statistical methods  

**In part 2**, average nitrogen loads across five different sources (urban land, atmospheric deposition, fertilizer, wastewater treatment, and grasslands), which suggests they used a one-way ANOVA, the standard method for comparing means across multiple categorical groups. The p-value of 0.02 indicates at least one group mean differs significantly from the others.  

Because no other details were provided, these are the most likely tests based on the language and p-values reported.  

## b. More information needed  

The test in part 2 looks like an ANOVA, which is good for comparing nitrogen load across sources. But to give more context, these could be added:

1. **Post-hoc test (like Tukey‚Äôs HSD)**. ANOVA tells us that at least one group is different, but not which ones. A post-hoc test helps identify which specific sources differ. 


## c. Suggestions for rewriting 






# Problem 2

## a. Cleaning and summarizing

Below you can find code to clean and summarize the 'sst' data set:

```{r cleaning sst data}


sst_clean <- sst |> # new df using sst data
  # Convert data types
  mutate(
    date = as.Date(date, format = "%Y-%m-%d"),   # Format date as YYYY-MM-DD
    site = as.character(site),                   # Make site a character
    latitude = as.numeric(latitude),             # Make latitude numeric
    longitude = as.numeric(longitude),           # Make longitude numeric
    temp = as.numeric(temp)                      # Make temp numeric
  ) |>

  # Create year and month columns
  mutate(
    year = factor(format(date, "%Y"), levels = as.character(2018:2023)),  # Year as factor
    month = factor(format(date, "%b"), levels = month.abb, ordered = TRUE)  # Ordered month names
  ) |>
 drop_na() |>  # Remove rows with na

  group_by(year, month) |>  # Group by year and month

  summarise(
    mean_monthly_sst = mean(temp),  # Calculate mean temp for each group
    .groups = "drop"                # Ungroup after summarizing
  )

```


```{r data structure}

slice_sample(   # Preview n=5 rows of new df
  sst_clean,
  n = 5)

str(sst_clean) # View structure of new df

```

## b. Visualize the data


```{r line plot, warning=FALSE, error=FALSE}

ggplot(sst_clean, aes(x = month, y = mean_monthly_sst, group = factor(year), color = factor(year))) +
  geom_line(size = 0.8) +  # Add lines 
  geom_point() +  # Add points
  scale_color_paletteer_d("colRoz::sky", name = "Year") +  #  Discrete palette with gradient-like blue tones by year
      # Axes labels
  labs(
    y = "Mean monthly sea surface temperature (¬∞C)",  # Y-axis label
    x = "Month"  # X-axis label
  ) +

  # Apply a clean black-and-white theme and customize appearance
  theme_bw(base_size = 12) +  # Use a simple, readable theme
  theme(
    panel.grid = element_blank(),  # Remove default gridlines
    legend.position = c(0.1, 0.75),  # Position legend inside plot
    axis.title.x = element_text(size = 14),  # Larger x-axis title
    axis.title.y = element_text(size = 14)   # Larger y-axis title
  )


```


# Problem 3. Data analysis

**Research Questions**

1. How do year (2016 or 2019) and distance from forest edge predict Swift Parrot (Lathamus discolor) nest box occupancy?

2. Is there a simpler model that explains Swift Parrot nest box occupancy, and if so, what is it?

## a. Response variable 

A '1' indicates that a nest box was occupied by a bird species during the observation period, meaning there was evidence such as adults, eggs, or nestlings. A '0' means the nest box was not occupied or showed no signs of nesting when checked.

## b. Purpose of study

The study focuses on the Swift Parrot, a critically endangered target species for which the nest boxes were deployed to aid conservation. In contrast, Common Starlings and Tree Martins are competitor species whose use of the boxes may reduce nesting opportunities for Swift Parrots, potentially undermining conservation efforts.

## c. Difference in ‚Äúseasons‚Äù 

The two ‚Äúseasons‚Äù refer to the years 2016 and 2019, representing the initial deployment of newly installed nest boxes and a later time point when the boxes had been established for several years. The study compares these seasons to examine how nest box use and species interactions may change over time as birds become familiar with the boxes.


## d. Table of models


### Model Table

| Model Number | Season | Distance to Forest Edge | Predictor List                      |
|--------------|--------|-------------------------|-------------------------------------|
| 0            |        |                         | No predictors (null model)          |
| 1            |   X    |            X            | All predictors (saturated model)    |
| 2            |   X    |                         | Season only                         |
| 3            |        |            X            | Distance to forest edge only        |


## e. Run the models 

```{r, cleaning nest_box data}

nest_boxes_clean <- nest_boxes |> 
  clean_names() |>                           # Clean column names to consistent lowercase snake_case
  rename(
    swift_parrot = sp,                      # Rename 'sp' column to 'swift_parrot'
    common_starling = cs,                   # Rename 'cs' to 'common_starling'
    tree_martin = tm,                       # Rename 'tm' to 'tree_martin'
    empty = e                              # Rename 'e' to 'empty'
  ) |> 
  mutate(
    season = as.factor(season),             # Convert 'season' to a factor (categorical)
    season = fct_relevel(season, "2016"),  # Set '2016' as the reference level in 'season'
    swift_parrot = as.integer(swift_parrot) # Convert 'swift_parrot' to integer (0/1 response)
  ) |> 
  select(swift_parrot, season, edge_distance) # Keep only the columns needed for modeling

```

```{r, fitting nest_box models}

# Null model: predicts Swift Parrot occupancy without any predictors (intercept only)
model0 <- glm(swift_parrot ~ 1, 
              data = nest_boxes_clean, 
              family = "binomial")

# Saturated model: predicts Swift Parrot occupancy using both season and edge distance
model1 <- glm(swift_parrot ~ season + edge_distance, 
              data = nest_boxes_clean, 
              family = "binomial")

# Model with season only: predicts Swift Parrot occupancy using season as predictor
model2 <- glm(swift_parrot ~ season, 
              data = nest_boxes_clean, 
              family = "binomial")

# Model with edge distance only: predicts Swift Parrot occupancy using edge distance as predictor
model3 <- glm(swift_parrot ~ edge_distance, 
              data = nest_boxes_clean, 
              family = "binomial")

```

## f. Check the diagnostics

```{r diagnostics check all models}

# Model 0 (null model with no predictors)
sim_res0 <- simulateResiduals(fittedModel = model0)   # simulate residuals for null model
plot(sim_res0)                                        # plot diagnostics for null model

# Model 1 (season + edge_distance)
sim_res1 <- simulateResiduals(fittedModel = model1)   # simulate residuals for full model
plot(sim_res1)                                        # plot diagnostics for full model

# Model 2 (season only)
sim_res2 <- simulateResiduals(fittedModel = model2)   # simulate residuals for season-only model
plot(sim_res2)                                        # plot diagnostics for season-only model

# Model 3 (edge_distance only)
sim_res3 <- simulateResiduals(fittedModel = model3)   # simulate residuals for edge_distance-only model
plot(sim_res3)                                        # plot diagnostics for edge_distance-only model

```


## e. Select the best model


```{r AIC}

# Calculate AIC for each model
model_aic <- AIC(model0,
                  model1, 
                  model2, 
                  model3)

# Print AIC table sorted by AIC (lowest first)
model_aic

```

```{r summary or model1}

# Show summary of best model
summary(model1)

```

**Interpretation**

The best model, based on Akaike‚Äôs Information Criterion (AIC), includes both season and distance from the forest edge (model1) as predictors of Swift Parrot nest box occupancy. This model provides the best balance of signal (meaningful information) to noise (random variation).


## Visualize the model predictions 

```{r model prediction plots}



model1_predictions <- ggpredict(model1, terms = c("edge_distance", "season"))


print(model1_predictions)

```


## 6. Final figure

```{r}

ggplot(data = model1_predictions,
       aes(x = x, 
           y = predicted, 
           color = group, 
           fill = group)) +
  geom_line(size = 1) +
  
  geom_ribbon(aes(ymin = conf.low,
                  ymax = conf.high), 
              alpha = 0.2, 
              color = NA) +
  labs(x = "Distance from forest edge (m)", 
       y = "Probability of swift parrot occupancy",
       color = "Season", 
       fill = "Season") +
  theme_minimal() +
  scale_color_manual(values = c("2016" = "turquoise3", "2019" = "coral3")) +
  scale_fill_manual(values = c("2016" = "turquoise3", "2019" = "coral3")) +
   # Remove gridlines for a cleaner look
  theme_classic() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
  

```


